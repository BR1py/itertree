

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>itertree.itree_main &mdash; itertree 0.1.1 Beta documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../Index_itertree.html" class="icon icon-home" alt="Documentation Home"> itertree
          

          
          </a>

          
            
            
              <div class="version">
                0.1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../Index_itertree.html">itertree</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../Index_itertree.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>itertree.itree_main</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for itertree.itree_main</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">This file contains the main iTree object</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">RLock</span>
<span class="kn">from</span> <span class="nn">.itree_data</span> <span class="kn">import</span> <span class="n">iTData</span>
<span class="kn">from</span> <span class="nn">.itree_helpers</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># This really recommended for faster operations!</span>
    <span class="kn">from</span> <span class="nn">blist</span> <span class="kn">import</span> <span class="n">blist</span>
    <span class="n">BLIST_SWITCH</span><span class="o">=</span><span class="mi">100</span> <span class="c1"># for list &gt; BLIST_SWITCH we switch to blist objects for better performance</span>
<span class="k">except</span><span class="p">:</span>
    <span class="c1"># if not available we take normal list</span>
    <span class="n">blist</span><span class="o">=</span><span class="nb">list</span>
    <span class="n">BLIST_SWITCH</span><span class="o">=-</span><span class="mi">1</span>

<span class="n">list_creator</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="c1"># helper for quick list instance</span>

<span class="c1">#class iTree(iTMagicList):</span>
<div class="viewcode-block" id="iTree"><a class="viewcode-back" href="../../itertree.html#itertree.iTree">[docs]</a><span class="k">class</span> <span class="nc">iTree</span><span class="p">(</span><span class="n">blist</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This is the main class related to iTrees.</span>

<span class="sd">    We give here a short functional summary:</span>

<span class="sd">    This object is the parent of a sub-tree (children, sub-children, etc.). The iTree object itself can also be a</span>
<span class="sd">    child of a parent iTree object. If this is not the case the iTree object is the root of the tree.</span>

<span class="sd">    A iTree object can only be integrated in one tree (one parent only)!</span>

<span class="sd">    Each iTree object contains a tag. In case your tags are stings it&#39;s recommended to use tag strings without</span>
<span class="sd">    wildcards &quot;*&quot;,&quot;?&quot; and without the standard separators &quot;/&quot; and &quot;#&quot;. If you use these characters you might get</span>
<span class="sd">    confusing results in find, filter and match operations.</span>

<span class="sd">    In general we allow all hashable objects to be used as a tag in the iTree objects (only search operation might be</span>
<span class="sd">    limited in this case).</span>
<span class="sd">    But we have two exceptions: We do not allow integers and TagIdx objects as tags because those objects used for</span>
<span class="sd">    direct item access.</span>

<span class="sd">    Different than in dictionaries it is allowed to put multiple times the same tag inside the iTree. The items with</span>
<span class="sd">    the same tag are placed and ordered (enumerated) in the related tag-family. They can be reached via TagIdx</span>
<span class="sd">    objects by giving the tag, index pair (tag_idx).</span>

<span class="sd">    Linked iTree objects will behave different. They have a read only structure (children) and they contain</span>
<span class="sd">    the children (tree) of the linked iTree.</span>
<span class="sd">    The &quot;local&quot; attributes like tag, data, ... can be set independent from the linked item (local properties).</span>
<span class="sd">    To change the tree structure of such an object you must manipulated the source object and reload the link.</span>

<span class="sd">    Additionally a iTree object can contain:</span>

<span class="sd">    * data - a iTData object to store any kind of python objects</span>

<span class="sd">    * couple - you can couple the object to another one by giving a pointer</span>

<span class="sd">    * is_temporary - you can mark it as temporary. Those iTree items behave like normal ones. But they will not be</span>
<span class="sd">      considered during encoding for storage, etc.</span>

<span class="sd">    There are different ways to access the children and sub-children in the tree of a iTree object.</span>

<span class="sd">    The standard access for single items is via itree_obj[] (__getitem__()) call.</span>

<span class="sd">    More complex access is available via find() and findall() methods. Have a look in the documentation</span>
<span class="sd">    related to each method.</span>

<span class="sd">    The delivery of access related operations in the iTree objects is for unique targets an</span>
<span class="sd">    iTree object and for multi target operations an iterator over the matching items. We don&#39;t deliver</span>
<span class="sd">    something like a list.</span>

<span class="sd">    If really needed an iterator can be easily converted into a list by list() method but this may take a long time</span>
<span class="sd">    for huge iterators. The iterator should only be used in the final step of the operation. It&#39;s recommended to have</span>
<span class="sd">    a look into itertools for better usage of the delivered iterators.</span>

<span class="sd">    The design of the object is made to have best possible performance even that it is pure python.</span>
<span class="sd">    For more details you may run the performance tests in the test section (But you might have to install</span>
<span class="sd">    additional packages run the comparisons and to get the full picture.)</span>

<span class="sd">    The function related to iterations iter; iter_children and find_all can be used with an item_filter. By this</span>
<span class="sd">    mechanism you can create queries regarding any property in an iTree.</span>

<span class="sd">    To initialize the class the following parameters are available</span>

<span class="sd">    :param tag: tag string or hashable object used for the iTree identification</span>
<span class="sd">    :param data: data dict or item to be stored in the node</span>
<span class="sd">    :param link: in case the node should be linked to another (external file/key) a iTLink() object can be given</span>
<span class="sd">    :param is_temp: If the iTree is marked as temporary the iTree will not be stored during dump into a file</span>
<span class="sd">    :param subtree: The subtree is a iterable structure that contains sub-items (iTree objects) that should be \</span>
<span class="sd">                    the children of this iTree.</span>

<span class="sd">                    .. warning:: subtree: In case the given iTree objects have already a parent an implicit copy will</span>
<span class="sd">                                          be made.</span>
<span class="sd">    &#39;&#39;&#39;</span>


    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;_tag&#39;</span><span class="p">,</span> <span class="s1">&#39;_parent&#39;</span><span class="p">,</span> <span class="s1">&#39;_map&#39;</span><span class="p">,</span> <span class="s1">&#39;_flags&#39;</span><span class="p">,</span> <span class="s1">&#39;_coupled&#39;</span><span class="p">,</span> <span class="s1">&#39;_link&#39;</span><span class="p">,</span> <span class="s1">&#39;_data&#39;</span><span class="p">,</span> <span class="s1">&#39;_cache&#39;</span><span class="p">,</span> <span class="s1">&#39;_def_serializer&#39;</span><span class="p">)</span>
        <span class="c1">#&#39;_length&#39;,&#39;_items&#39;,&#39;_is_list&#39;)</span>
<div class="viewcode-block" id="iTree.__init__"><a class="viewcode-back" href="../../Index_itertree.html#itertree.iTree.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">link</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_temp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subtree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="nb">int</span><span class="p">,</span> <span class="n">TagIdx</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Given tag cannot be used in iTree wrong type (int or TagIdx)&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span> <span class="o">=</span> <span class="n">tag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">=</span> <span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coupled</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">link</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_link</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="s1">&#39;is_iTLink&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Error given link is not of type iTLink&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_link</span> <span class="o">=</span> <span class="n">link</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">=</span> <span class="n">LINKED</span>

        <span class="k">if</span> <span class="n">is_temp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">|</span> <span class="n">TEMPORARY</span>

        <span class="k">if</span> <span class="n">subtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;is_iTData&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">=</span> <span class="n">iTData</span><span class="p">(</span><span class="n">data_items</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span></div>

    <span class="c1"># These are the mandatory methods we expect in the data object</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        set function for a data-attribute</span>

<span class="sd">        In case the standard iTData object is used we have:</span>

<span class="sd">        :param key: give key under which the data will be stored, in case data is None the first key parameter is taken</span>
<span class="sd">                    as data object and it is stored in the &quot;__NOKEY__&quot; item</span>

<span class="sd">        :param value: data value the object that should be stored in the data structure of this iTree</span>

<span class="sd">        :return  None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_linked</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;Linked item cannot be manipulated&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        get function for a data attribute</span>

<span class="sd">        In case the standard iTData object is used we have:</span>

<span class="sd">        :param key: key under which the data is stored, in case no key is given the &quot;__NOKEY__&quot; item will be returned</span>

<span class="sd">        :return: data attribute object</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        check if the given data-item can be stored under the given key. The check make only sense in case there is</span>
<span class="sd">        a iTreeDataModel or matching object is already stored under the key</span>

<span class="sd">        :param value: data value the object that should be checked</span>
<span class="sd">        :param key: give key under which contains the DataModel, in case key is None the &quot;__NOKEY__&quot; item will be used</span>

<span class="sd">        :return: tuple (True/False,&#39;check details&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_linked</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;Linked item cannot be manipulated&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">check</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pop_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        data related pop (will delete the given key</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">parent</span><span class="o">.</span><span class="n">_is_linked</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;Linked item cannot be manipulated&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">pop</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>


<div class="viewcode-block" id="iTree.init_serializer"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.init_serializer">[docs]</a>    <span class="k">def</span> <span class="nf">init_serializer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exporter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">importer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">serializer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">renderer</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Method sets the exchange environment that should be used. If you leave the parameters as default,</span>
<span class="sd">        the standard objects will be used.</span>

<span class="sd">        HINT: The method logic is called only one time the first time serializing is needed.</span>
<span class="sd">              For standard serializer post import must be done against common python rules</span>
<span class="sd">              because pre import will lead into cyclic importing</span>

<span class="sd">        :param force: False (Default) - do not reload in case we have already loaded the items</span>
<span class="sd">        :param exporter: exporter object for file export of iTree (dump, dumps)</span>
<span class="sd">        :param importer: importer object in ces a file import is done (load, loads)</span>
<span class="sd">        :param serializer: Object serializer (especially needed for data objects!)</span>
<span class="sd">        :param renderer:  A renderer for pretty print output of the iTree object</span>

<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">serializer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">.itree_serialize</span> <span class="kn">import</span> <span class="n">iTStdObjSerializer</span>
                <span class="n">serializer</span> <span class="o">=</span> <span class="n">iTStdObjSerializer</span>
            <span class="k">if</span> <span class="n">exporter</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">importer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">.itree_serialize</span> <span class="kn">import</span> <span class="n">iTStdJSONSerializer</span>
                <span class="k">if</span> <span class="n">exporter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">exporter</span> <span class="o">=</span> <span class="n">iTStdJSONSerializer</span><span class="p">(</span><span class="n">obj_serializer</span><span class="o">=</span><span class="n">serializer</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">importer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">importer</span> <span class="o">=</span> <span class="n">iTStdJSONSerializer</span><span class="p">(</span><span class="n">obj_serializer</span><span class="o">=</span><span class="n">serializer</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">renderer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">.itree_serialize</span> <span class="kn">import</span> <span class="n">iTStdRenderer</span>
                <span class="n">renderer</span> <span class="o">=</span> <span class="n">iTStdRenderer</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span> <span class="o">=</span> <span class="p">(</span><span class="n">exporter</span><span class="p">,</span> <span class="n">importer</span><span class="p">,</span> <span class="n">serializer</span><span class="p">,</span> <span class="n">renderer</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.__setitem__"><a class="viewcode-back" href="../../Index_itertree.html#itertree.iTree.__setitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        put the item in the iTree for (re)setting a child</span>

<span class="sd">        HINT: A iTree child can only be child of one iTree (one parent only)</span>
<span class="sd">        HINT2: Linked items cannot be changed change the linked item and reload the tree!</span>

<span class="sd">        :param key: single identifier for the item can be integer index or TagIdx</span>
<span class="sd">        :param value: iTree object that should be child of called iTree</span>

<span class="sd">        :return: value</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;In linked iTrees we cannot change the structure&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># e.g. for __iadd__ operation we may find exactly same item already in the tree</span>
                    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">idx</span><span class="p">)):</span>
                        <span class="c1"># we must do nothing in that case</span>
                        <span class="k">return</span> <span class="n">value</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">raise</span> <span class="ne">RecursionError</span><span class="p">(</span><span class="s1">&#39;Given item has already a parent iTree!&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">iTree</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;In iTree only children of type iTree can be integrated&#39;</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="n">old_item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">old_item</span><span class="o">.</span><span class="n">idx</span>
        <span class="n">o_tag</span> <span class="o">=</span> <span class="n">old_item</span><span class="o">.</span><span class="n">_tag</span>
        <span class="n">value</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">v_tag</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">_tag</span>
        <span class="k">if</span> <span class="n">v_tag</span> <span class="o">==</span> <span class="n">o_tag</span><span class="p">:</span>
            <span class="n">family</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="p">[</span><span class="n">v_tag</span><span class="p">]</span>
            <span class="n">family</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">old_item</span><span class="o">.</span><span class="n">tag_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_map</span>
            <span class="n">m</span><span class="p">[</span><span class="n">old_item</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">old_item</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">family</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">v_tag</span><span class="p">]</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_family_insertion_idx</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">idx</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">family</span><span class="p">)</span><span class="o">==</span><span class="n">BLIST_SWITCH</span><span class="p">:</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">v_tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">family</span> <span class="o">=</span> <span class="n">blist</span><span class="p">(</span><span class="n">family</span><span class="p">)</span>
                <span class="n">family</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[</span><span class="n">v_tag</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">value</span></div>

<div class="viewcode-block" id="iTree.__getitem__"><a class="viewcode-back" href="../../Index_itertree.html#itertree.iTree.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span><span class="n">str_index_separator</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Main getter for items</span>

<span class="sd">        If given key targets to only one item we will deliver an iTree. If no matching item is found an IndexError</span>
<span class="sd">        or KeyError exception will be raised.</span>

<span class="sd">        If the given key targets to multiple items (tag family, slice, itearble of single target keys) and iterator</span>
<span class="sd">        will be delivered.</span>

<span class="sd">        .. node:: If a tag is given a iterator of the tag family will be returned even if there is only one item</span>
<span class="sd">                  with the tag in the tree!!!</span>

<span class="sd">        :param key: single target: index, TagIdx or tuple (tag, index) (not recommended)</span>
<span class="sd">                    multi target: TagIdx_s; iMatch; slice or an iterable (like list) of these keys</span>
<span class="sd">        :return: iTree item or iterator (multi target)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">TagIdx</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">is_single</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">family</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t2</span> <span class="ow">is</span> <span class="nb">slice</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">idxs</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">idxs</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">idxs</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">t2</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">idxs</span><span class="p">,</span> <span class="s1">&#39;__next__&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">iter</span><span class="p">([</span><span class="n">family</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TagIdx object contains invalid indexes&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">slice</span><span class="p">:</span>
            <span class="c1"># return an iterator over the slice</span>
            <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">(),</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">iTMatch</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">key</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">item</span><span class="p">),</span><span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;__next__&#39;</span><span class="p">):</span>
            <span class="c1"># list or iterator HINT: We expect that the items are valid items like integer index or TagIdx items</span>
            <span class="c1"># -&gt; return an iterator</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># here we expect a tag only and we deliver the related iterator</span>
            <span class="n">m</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_map</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># we return a family iterator here</span>
                <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># less quick not recommended options:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">str_index_separator</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">TagIdx</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">tag_separator</span><span class="o">=</span><span class="n">str_index_separator</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                    <span class="c1"># we recheck here for tuples (tag,index)</span>
                    <span class="c1"># but it&#39;s recommended to use TagIdx objects instead</span>
                    <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">raise</span> <span class="ne">KeyError</span></div>

<div class="viewcode-block" id="iTree.__delitem__"><a class="viewcode-back" href="../../Index_itertree.html#itertree.iTree.__delitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        delete an item in the tree</span>
<span class="sd">        :param key: key targeting the item to be deleted</span>
<span class="sd">                    single target: iTree object (remove), index, TagIdx or tuple (tag, index) (not recommended)</span>
<span class="sd">                    multi target: TagIdx_s or an iterable (like list) of these keys or a slice</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;In linked iTrees we cannot change the structure&#39;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">m</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_map</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">del_item</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">family</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">del_item</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">m</span><span class="p">[</span><span class="n">del_item</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">family</span><span class="p">[</span><span class="n">del_item</span><span class="o">.</span><span class="n">tag_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">del_item</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">del_item</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">TagIdx</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">is_single</span><span class="p">:</span>
                <span class="n">family</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">del_item</span> <span class="o">=</span> <span class="n">family</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">m</span><span class="p">[</span><span class="n">del_item</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span>
                <span class="c1"># here we go for _delitem__ and not remove because we expect the item &quot;knows&quot; the correct index (cache)</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">del_item</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">del_item</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">return</span> <span class="n">del_item</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idxs</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">family</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">t2</span> <span class="ow">is</span> <span class="nb">slice</span><span class="p">:</span>
                    <span class="n">del_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">idxs</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">idxs</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">idxs</span><span class="o">.</span><span class="n">step</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">t2</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;__next__&#39;</span><span class="p">):</span>
                    <span class="n">del_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">family</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TagIdx_s object contains invalid indexes&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">del_list</span><span class="p">:</span>
                    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
                    <span class="n">tag_idx</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">tag_idx</span>
                    <span class="n">family</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">tag_idx</span><span class="o">.</span><span class="n">tag</span><span class="p">]</span>
                    <span class="n">del_item</span> <span class="o">=</span> <span class="n">family</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag_idx</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">m</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag_idx</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
                    <span class="n">del_item</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">del_list</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;is_iTree&#39;</span><span class="p">):</span>
            <span class="c1"># ToDo delete in the parent?</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">idx</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">tag_idx</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">tag_idx</span>
            <span class="n">family</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">tag_idx</span><span class="o">.</span><span class="n">tag</span><span class="p">]</span>
            <span class="n">del_item</span> <span class="o">=</span> <span class="n">family</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag_idx</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">m</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag_idx</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
            <span class="n">del_item</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">del_item</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># family tag given?</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">family</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># iterator or iterable given?</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;__next__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;__next__&#39;</span><span class="p">):</span>
                    <span class="c1"># return an iterator over the slice</span>
                    <span class="n">return_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">return_list</span><span class="p">:</span>
                        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
                        <span class="n">tag_idx</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">tag_idx</span>
                        <span class="n">family</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">tag_idx</span><span class="o">.</span><span class="n">tag</span><span class="p">]</span>
                        <span class="n">del_item</span> <span class="o">=</span> <span class="n">family</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag_idx</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">m</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag_idx</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
                        <span class="n">del_item</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">return_list</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># no valid key found!</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;No related item (key = </span><span class="si">%s</span><span class="s1">) found for deletion&#39;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">family</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">family</span><span class="p">:</span>
                <span class="n">i</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">family</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Multiplication function a iTree is multiplied (copies) and put in a new iTree:</span>

<span class="sd">        my_single_item=iTree(&#39;multi&#39;)</span>
<span class="sd">        multi=my_single_item*1000</span>

<span class="sd">        HINT: In this operation multiple copies of the original item generated.</span>

<span class="sd">        :param factor: integer to multiply with</span>
<span class="sd">        :return: iTree object containing multiplied children</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">iTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">subtree</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">factor</span><span class="p">)])</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        If two iTree objects are added the children in the two added iTrees are copied and combined</span>
<span class="sd">        to a new iTree object the other attributes are taken over from the first iTree in the sum</span>

<span class="sd">        :param other: iTree object that should be added</span>
<span class="sd">        :return: New iTree object containing copies of all children</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;In linked iTrees we cannot change the structure&#39;</span><span class="p">)</span>
        <span class="n">items</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;_parent&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="k">continue</span>
            <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">iTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">subtree</span><span class="o">=</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This is the same operation as append (is a bit quicker)</span>
<span class="sd">        :param other: iTree object that should be added</span>
<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;In linked iTrees we cannot change the structure&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RecursionError</span><span class="p">(</span><span class="s1">&#39;Given item has already a parent iTree!&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">iTree</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;In iTree only children of type iTree can be integrated&#39;</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="c1"># append item:</span>
        <span class="n">other</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">cache</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">_cache</span>
        <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">m</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_map</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">family</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span>
            <span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span><span class="n">l</span><span class="o">=</span><span class="n">family</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">==</span><span class="n">BLIST_SWITCH</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span><span class="o">=</span><span class="n">family</span><span class="o">=</span><span class="n">blist</span><span class="p">(</span><span class="n">family</span><span class="p">)</span>
            <span class="n">family</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># first time tag is used!</span>
            <span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">m</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span> <span class="o">=</span><span class="p">[</span><span class="n">other</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="iTree.__iter__"><a class="viewcode-back" href="../../Index_itertree.html#itertree.iTree.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        standard iterator over all items in the iTree</span>
<span class="sd">        :param item_filter: ALL = default</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.__contains__"><a class="viewcode-back" href="../../Index_itertree.html#itertree.iTree.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        checks if an iTree object is part of the iTree</span>
<span class="sd">        :param item: iTree object we searching for</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">_parent</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">_parent</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.__eq__"><a class="viewcode-back" href="../../Index_itertree.html#itertree.iTree.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A iTree object is always unique we test therefore just for matching object IDs</span>
<span class="sd">        This is needed for quick index findings!</span>
<span class="sd">        ..node:: To check if properties content is equal use equal() instead</span>
<span class="sd">        :param other: iTree object to compare with</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">==</span><span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A iTree object is always unique we test therefore just for object for not matching IDs</span>
<span class="sd">        This is needed for quick index findings!</span>
<span class="sd">        ..node:: To check if attribute content is equal use not equal() instead</span>
<span class="sd">        :param other: other item to be compared with</span>
<span class="sd">        :return: True/False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        less than is a size comparison (length are compared)</span>
<span class="sd">        :param other: iTree object self should be compared with</span>
<span class="sd">        :return: True/False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        less than or equal is a size comparison (length are compared)</span>
<span class="sd">        :param other: iTree object self should be compared with</span>
<span class="sd">        :return: True/False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        greater than is a size comparison (length are compared)</span>
<span class="sd">        :param other: iTree object self should be compared with</span>
<span class="sd">        :return: True/False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        greater than or equal is a size comparison (length are compared)</span>
<span class="sd">        :param other: iTree object self should be compared with</span>
<span class="sd">        :return: True/False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="iTree.__repr__"><a class="viewcode-back" href="../../Index_itertree.html#itertree.iTree.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        create representation string from which the object can be reconstructed via eval (might not work in case of</span>
<span class="sd">        data that do not have a working repr method)</span>
<span class="sd">        :return: represenation string</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">repr_str</span> <span class="o">=</span> <span class="s1">&#39;iTree(&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_no_key_only</span><span class="p">:</span>
                <span class="n">repr_str</span> <span class="o">=</span> <span class="n">repr_str</span> <span class="o">+</span> <span class="s1">&#39;, data=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">repr_str</span> <span class="o">=</span> <span class="n">repr_str</span> <span class="o">+</span> <span class="s1">&#39;, data=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="n">repr_str</span> <span class="o">=</span> <span class="n">repr_str</span> <span class="o">+</span> <span class="s1">&#39;, link=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">TEMPORARY</span><span class="p">:</span>
            <span class="n">repr_str</span> <span class="o">=</span> <span class="n">repr_str</span> <span class="o">+</span> <span class="s1">&#39;, is_temp=True&#39;</span>
        <span class="k">if</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="o">&amp;</span><span class="n">LINKED</span><span class="p">:</span>
            <span class="n">subtree</span><span class="o">=</span><span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">subtree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="c1"># we shorten blist from definition</span>
                <span class="n">subtree</span><span class="o">=</span><span class="n">subtree</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">repr_str</span> <span class="o">+</span> <span class="s1">&#39;, subtree=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">subtree</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">repr_str</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span></div>

<div class="viewcode-block" id="iTree.__hash__"><a class="viewcode-back" href="../../Index_itertree.html#itertree.iTree.__hash__">[docs]</a>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The hash operation is available but not a quick operation!</span>
<span class="sd">        ..node::: We do here not consider, parent and coupled item</span>
<span class="sd">        :return: integer hash</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">N</span> <span class="o">|</span> <span class="n">T</span><span class="p">)),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)))</span></div>

<div class="viewcode-block" id="iTree.__len__"><a class="viewcode-back" href="../../Index_itertree.html#itertree.iTree.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span></div>

    <span class="c1"># unsupported operands</span>
    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unsupport_op</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unsupport_op</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unsupport_op</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unsupport_op</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unsupport_op</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unsupport_op</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__reduce_ex__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unsupport_op</span><span class="p">()</span>

<div class="viewcode-block" id="iTree.sort"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unsupport_op</span><span class="p">()</span></div>

    <span class="c1"># properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_iTree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This property is used to quick identify the iTree objects (much quicker than isinstance())</span>
<span class="sd">        :return: True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_linked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Are the sub items of this item linked ones?</span>
<span class="sd">        :return: True/False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="o">&amp;</span><span class="n">LINKED</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_link_loaded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For linked iTree objects we deliver here the state of loading the links</span>
<span class="sd">        :return: True/False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="o">&amp;</span><span class="n">LINKED</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="o">.</span><span class="n">is_loaded</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        property contains the parent item</span>

<span class="sd">        :return: iTree parent object (or None in case no parent exists)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        is this item a root item (no parent)</span>

<span class="sd">        :return: True/False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        property delivers the root item of the tree</span>

<span class="sd">        :return: iTree root item</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">root</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pre_item</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        delivers the pre item (predecessor) of this object</span>
<span class="sd">        :return: iTree predecessor or None (no match)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">post_item</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        delivers the post item (successor)</span>
<span class="sd">        :return: iTree successor or None (no match)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        delivers the distance (number of levels) to the root element of the tree</span>

<span class="sd">        :return: integer</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">idx_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        delivers the a list of indexes from the root to this item</span>

<span class="sd">        :return: list of index integers (here we do not deliver an iterator)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">idx_path</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tag_idx_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        delivers the a list of TagIdx objects from the root to this item</span>

<span class="sd">        :return: list of TagIdx (here we do not deliver an iterator)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">tag_idx_path</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tag_idx</span><span class="p">]</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tag_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the TagIdx object related to this object</span>
<span class="sd">        (contains the tag and the index of the object in the tag-family)</span>
<span class="sd">        :return: TagIdx</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># we use cached index to be quicker</span>
        <span class="n">cache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cahce</span>
        <span class="n">c_idx</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">family</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">family</span><span class="p">[</span><span class="n">c_idx</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">TagIdx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span><span class="n">c_idx</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># we search nearby</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">i</span><span class="o">=</span><span class="n">family</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,(</span><span class="n">c_idx</span><span class="o">-</span><span class="mi">10</span><span class="p">),(</span><span class="n">c_idx</span><span class="o">+</span><span class="mi">10</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">idx</span><span class="o">=</span><span class="n">i</span>
                <span class="k">return</span> <span class="n">TagIdx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span><span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="c1"># full search cached index must be updated</span>
        <span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TagIdx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This objects tag</span>
<span class="sd">        :return: tag object</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Index of this object in the iTree</span>
<span class="sd">        :return: integer index</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># we use cached index to be quicker</span>
        <span class="n">cache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span>
        <span class="n">order</span><span class="o">=</span><span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">c_idx</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">order</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">c_idx</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">c_idx</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># we search nearby</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">i</span><span class="o">=</span><span class="n">order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,(</span><span class="n">c_idx</span><span class="o">-</span><span class="mi">10</span><span class="p">),(</span><span class="n">c_idx</span><span class="o">+</span><span class="mi">10</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
               <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">idx</span><span class="o">=</span><span class="n">i</span>
               <span class="k">return</span> <span class="n">idx</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span><span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="c1"># cached index must be updated</span>
        <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_temporary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The iTree object can be marked as temporary (this means it will not be stored in a file if exported)</span>
<span class="sd">        This properties checks if the item is temporary</span>
<span class="sd">        :return: True/False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coupled_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The iTree object can be couple with another python object. The pointer to the object is stored and can be</span>
<span class="sd">        reached via this property. (E.g. this can be helpful when connecting the iTree with a visual grafical element</span>
<span class="sd">        (treelist item) in a GUI)</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coupled</span>


    <span class="c1"># set properties</span>

<div class="viewcode-block" id="iTree.set_temporary"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.set_temporary">[docs]</a>    <span class="k">def</span> <span class="nf">set_temporary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">parent</span><span class="o">.</span><span class="n">_is_linked</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;Linked item cannot be manipulated&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">TEMPORARY</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">|</span> <span class="n">TEMPORARY</span>  <span class="c1">#</span></div>

<div class="viewcode-block" id="iTree.unset_temporary"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.unset_temporary">[docs]</a>    <span class="k">def</span> <span class="nf">unset_temporary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">parent</span><span class="o">.</span><span class="n">_is_linked</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;Linked item cannot be manipulated&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">TEMPORARY</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="o">~</span> <span class="n">TEMPORARY</span></div>

<div class="viewcode-block" id="iTree.set_couple_object"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.set_couple_object">[docs]</a>    <span class="k">def</span> <span class="nf">set_couple_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">couple_object</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        User can couple this object with others with the help of this attribute</span>
<span class="sd">        HINT: E.g. this might be an object in a GUI that are related to this item</span>
<span class="sd">        :param couple_object:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coupled</span> <span class="o">=</span> <span class="n">couple_object</span></div>

<div class="viewcode-block" id="iTree.equal"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.equal">[docs]</a>    <span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">check_parent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_coupled</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        compares if the data content of another item matches with this item</span>
<span class="sd">        :param other: other iTree</span>
<span class="sd">        :param check_coupled: check the couple object too? (Default False)</span>
<span class="sd">        :return: boolean match result (True match/False no match)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">iTree</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">check_parent</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">_parent</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="n">my_data</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="p">)</span>
        <span class="n">other_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_flags</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_map</span><span class="p">),</span> <span class="n">other</span><span class="o">.</span><span class="n">_link</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">my_data</span> <span class="o">!=</span> <span class="n">other_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">oi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">ALL</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">ALL</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">si</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">oi</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">check_coupled</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coupled</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_coupled</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="iTree.copy"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy_data</span><span class="o">=</span><span class="n">COPY_NORMAL</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        create a copy of this item</span>

<span class="sd">        The function is used internally in extend operations too. And we can see (profiler) that</span>
<span class="sd">        improvements in this method might have big impact.</span>

<span class="sd">        :param copy_data: Type of copy</span>
<span class="sd">                          COPY_OFF - keep the data uncopied</span>
<span class="sd">                          COPY_NORMAL - (default) copy the data too</span>
<span class="sd">                          COPY_DEEP - do a deepcopy()</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">copy_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linked</span><span class="p">:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">iTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span>
                        <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                        <span class="n">link</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="p">,</span>
                        <span class="n">is_temp</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">T</span><span class="p">)</span>
                        <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_link_loaded</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">load_links</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">iTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">,</span>
                        <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                        <span class="n">is_temp</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">T</span><span class="p">),</span>
                        <span class="n">subtree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">()</span> <span class="c1"># here we create a recursion!</span>
                        <span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="iTree.count"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        count the number of children that match to the given filter</span>
<span class="sd">        ::Note: The operation is not very quick on huge iTrees and complicate filters!</span>
<span class="sd">        :param item_filter:</span>
<span class="sd">        :return: integer number of children matching to the filter</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">item_filter</span> <span class="o">==</span> <span class="n">ALL</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">super</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item_filter</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">item_filter</span>
            <span class="n">item_filter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">item_filter</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">())))</span></div>

    <span class="c1"># structure manipulations</span>

<div class="viewcode-block" id="iTree.clear"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        deletes all children</span>
<span class="sd">        and data!</span>
<span class="sd">        flags stay unchanged!</span>
<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coupled</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="c1"># we clear only data not the tree!</span>
            <span class="k">return</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map</span> <span class="o">=</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="iTree.insert"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">insert_key</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Insert an item before a specific position</span>

<span class="sd">        :param insert_key: position key (integer index or TagIdx)</span>
<span class="sd">        :param value: item that should be inserted in the tree (new child)</span>
<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;In linked iTrees we cannot change the structure&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">iTree</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;In iTree only children of type iTree can be integrated&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RecursionError</span><span class="p">(</span><span class="s1">&#39;Given item has already a parent iTree!&#39;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">insert_key</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">insert_key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">insert_key</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span> <span class="o">-</span> <span class="n">idx</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">insert_key</span><span class="p">)</span> <span class="ow">is</span> <span class="n">TagIdx</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">insert_key</span><span class="p">)</span><span class="o">.</span><span class="n">idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;In iTree only children of type iTree can be integrated&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">_tag</span>
        <span class="n">m</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_map</span>
        <span class="n">cache</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="n">_cache</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">family</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
            <span class="n">l</span><span class="o">=</span><span class="n">family</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>
            <span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">==</span><span class="n">BLIST_SWITCH</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">=</span><span class="n">family</span><span class="o">=</span><span class="n">blist</span><span class="p">(</span><span class="n">family</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">m</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">family</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_family_insertion_idx</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="n">family</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">idx</span>
        <span class="n">item</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="iTree.append"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Append the given iTree object to the tree (new last child)</span>

<span class="sd">        :except: raise TypeError in case iTree object has already a parent</span>

<span class="sd">        :param item: iTree object to be appended</span>

<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.appendleft"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.appendleft">[docs]</a>    <span class="k">def</span> <span class="nf">appendleft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Append the given iTree object to the left of the the tree (new first child)</span>

<span class="sd">        :except: raise TypeError in case iTree object has already a parent</span>

<span class="sd">        :param item: iTree object to be appended</span>

<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">item</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.extend"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extend_items</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        We extend the iTree with given items (multi append)</span>

<span class="sd">        :note: In case the extend items have already a parent an implicit copy will be made. We do this because</span>
<span class="sd">               we might get an iTree-object as extend_items parameter and then the children will have automatically a</span>
<span class="sd">               parent even that the parent object might be a temporary one.</span>

<span class="sd">        :param extend_items: iterable object that contains iTree objects as items</span>
<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># collect for operation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;In linked iTrees we cannot change the structure&#39;</span><span class="p">)</span>
        <span class="n">sl</span><span class="o">=</span><span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">m</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_map</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">extend_items</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">item</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">_cache</span>
            <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">sl</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>
            <span class="n">sl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">tag</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="n">tag</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">family</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
                <span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span> <span class="o">=</span> <span class="n">family</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">BLIST_SWITCH</span><span class="p">:</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">family</span> <span class="o">=</span> <span class="n">blist</span><span class="p">(</span><span class="n">family</span><span class="p">)</span>
                <span class="n">family</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">m</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="iTree.extendleft"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.extendleft">[docs]</a>    <span class="k">def</span> <span class="nf">extendleft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extend_items</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        We extend the iTree with given items in the beginning (multi appendleft)</span>

<span class="sd">        :note: In case the extend items have already a parent an implicit copy will be made. We do this because</span>
<span class="sd">               we might get an iTree-object as extend_items parameter and then the children will have automatically a</span>
<span class="sd">               parent even that the parent object might be a temporary one.</span>

<span class="sd">        :note: The extendleft() operation is a lot slower then the normal extend operation</span>

<span class="sd">        :param extend_items: iterable object that contains iTree objects as items</span>
<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># start_idx=len(extend_items)-1</span>
        <span class="c1"># collect for operation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;In linked iTrees we cannot change the structure&#39;</span><span class="p">)</span>
        <span class="n">sl</span><span class="o">=</span><span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">m</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_map</span>
        <span class="n">l</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">extend_items</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="n">item</span><span class="o">=</span><span class="n">extend_items</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">item</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">item</span><span class="o">.</span><span class="n">_cache</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sl</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">item</span><span class="p">)</span>
            <span class="n">tag</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="n">_tag</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">family</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">family</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">BLIST_SWITCH</span><span class="p">:</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">family</span> <span class="o">=</span> <span class="n">blist</span><span class="p">(</span><span class="n">family</span><span class="p">)</span>
                <span class="n">family</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">item</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="iTree.pop"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        pop the item out of the tree, if no key is given the last item will be popped out</span>

<span class="sd">        :param key: specific identification key for an item (integer index, TagIdx)</span>

<span class="sd">        :return: popped out item (parent will be set to None)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.popleft"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.popleft">[docs]</a>    <span class="k">def</span> <span class="nf">popleft</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        pop the first item out of the tree</span>

<span class="sd">        :return: popped out item (parent will be set to None)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.remove"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        remove the given item out of the tree (delete the child)</span>

<span class="sd">        :param item: iTree object that should be removed from the tree</span>

<span class="sd">        :return: removed item will be returned (parent is set to None)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.move"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">insert_key</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        move the item in another position</span>

<span class="sd">        :param insert_key: item will be insert before this key</span>

<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="s1">&#39;Given item is not a children of a iTree!&#39;</span><span class="p">)</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="c1"># check if target exists:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">insert_key</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">target_idx</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">insert_key</span><span class="p">)</span><span class="o">.</span><span class="n">idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_idx</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">insert_key</span><span class="p">)</span><span class="o">.</span><span class="n">idx</span>
            <span class="n">target_idx</span> <span class="o">=</span> <span class="n">insert_key</span>
        <span class="n">src_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span>
        <span class="n">move_item</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">src_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target_idx</span> <span class="o">&gt;</span> <span class="n">src_idx</span><span class="p">:</span>
            <span class="n">target_idx</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">parent</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">target_idx</span><span class="p">,</span> <span class="n">move_item</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.rename"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_tag</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        give the item a new tag</span>

<span class="sd">        :param new_tag: new tag object string or hashable object</span>

<span class="sd">        :return: None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;In linked iTrees we cannot change the structure&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">new_tag</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="nb">int</span><span class="p">,</span> <span class="n">TagIdx</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Given tag cannot be used in iTree wrong type (int or TagIdx)&#39;</span><span class="p">)</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span> <span class="o">=</span> <span class="n">new_tag</span>
            <span class="k">return</span>
        <span class="n">family</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span>
        <span class="n">family</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">family</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">parent</span><span class="o">.</span><span class="n">_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span> <span class="o">=</span> <span class="n">new_tag</span>
        <span class="n">pm</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">_map</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_family</span> <span class="o">=</span> <span class="n">pm</span><span class="p">[</span><span class="n">new_tag</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_family</span><span class="p">)</span><span class="o">==</span><span class="n">BLIST_SWITCH</span><span class="p">:</span>
                <span class="n">pm</span><span class="p">[</span><span class="n">new_tag</span><span class="p">]</span><span class="o">=</span><span class="n">new_family</span><span class="o">=</span><span class="n">blist</span><span class="p">(</span><span class="n">new_family</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">pm</span><span class="p">[</span><span class="n">new_tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_family_insertion_idx</span><span class="p">(</span><span class="n">new_family</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">new_family</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.reverse"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.reverse">[docs]</a>    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;In linked iTrees we cannot change the structure&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">item</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span></div>

<div class="viewcode-block" id="iTree.rotate"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        rotate the whole iTree n times</span>
<span class="sd">        (rotate means move last element to first position, ...)</span>
<span class="sd">        :param n:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="s1">&#39;In linked iTrees we cannot change the structure&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">rot_item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rot_item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">rot_item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="bp">self</span> <span class="o">+=</span> <span class="n">rot_item</span></div>

    <span class="c1"># iterators</span>

<div class="viewcode-block" id="iTree.iter_all"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.iter_all">[docs]</a>    <span class="k">def</span> <span class="nf">iter_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">,</span> <span class="n">top_down</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">filter_or</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        main iterator for whole tree runs in top-&gt; down order</span>

<span class="sd">        :param item_filter: filter for filter the items you can give a filter constant or</span>
<span class="sd">                            a method for filtering (should return True/False)</span>
<span class="sd">        :param match: match pattern a iTMatch object</span>
<span class="sd">        :param top_down: True -  we start from parent to children</span>
<span class="sd">                          parent; child1; subchild1_1; subchild1_2; child2; subchild2_1</span>
<span class="sd">                         False - we start from children to parent</span>
<span class="sd">                          subchild1_1; subchild1_2; child1; subchild2_1;  child2; parent</span>
<span class="sd">        :param filter_or: True - we combine the filtering with or this means even if we have no match in the higher</span>
<span class="sd">                                 levels of the tree we will go deepere to find matches</span>
<span class="sd">                          False - filters are combined with and which means children will only be parsed in</span>
<span class="sd">                                  case the parent matches also to the filter condition</span>
<span class="sd">        :return: iterator</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item_filter</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">item_filter</span>
            <span class="n">item_filter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">top_down</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filter_or</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">item_filter</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">item</span>
                    <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">iter_all</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">,</span> <span class="n">top_down</span><span class="o">=</span><span class="n">top_down</span><span class="p">,</span> <span class="n">filter_or</span><span class="o">=</span><span class="n">filter_or</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">subitem</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">item</span>
                    <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">iter_all</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">,</span><span class="n">top_down</span><span class="o">=</span><span class="n">top_down</span><span class="p">,</span><span class="n">filter_or</span><span class="o">=</span><span class="n">filter_or</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">subitem</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filter_or</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">iter_all</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">,</span> <span class="n">top_down</span><span class="o">=</span><span class="n">top_down</span><span class="p">,</span> <span class="n">filter_or</span><span class="o">=</span><span class="n">filter_or</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">subitem</span>
                    <span class="k">if</span> <span class="n">item_filter</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">item</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">iter_all</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">,</span><span class="n">top_down</span><span class="o">=</span><span class="n">top_down</span><span class="p">,</span><span class="n">filter_or</span><span class="o">=</span><span class="n">filter_or</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">subitem</span>
                    <span class="k">yield</span> <span class="n">item</span></div>

<div class="viewcode-block" id="iTree.iter_children"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.iter_children">[docs]</a>    <span class="k">def</span> <span class="nf">iter_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        main iterator in children level</span>
<span class="sd">        :param item_filter: the items can be filtered by giving a filter constants or giving a filter method</span>
<span class="sd">        :return: iterator</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item_filter</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">item_filter</span>
            <span class="n">item_filter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="n">item_filter</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">())</span></div>

<div class="viewcode-block" id="iTree.iter_tag_idxs"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.iter_tag_idxs">[docs]</a>    <span class="k">def</span> <span class="nf">iter_tag_idxs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">,</span> <span class="n">top_down</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">tag_cnts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">,</span> <span class="n">top_down</span><span class="o">=</span><span class="n">top_down</span><span class="p">):</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">_tag</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="n">tag_cnts</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">tag_cnts</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span>
                <span class="k">yield</span> <span class="n">TagIdx</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">cnt</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">tag_cnts</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">yield</span> <span class="n">TagIdx</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.find_all"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.find_all">[docs]</a>    <span class="k">def</span> <span class="nf">find_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_path</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">,</span> <span class="n">str_path_separator</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">str_index_separator</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span>
                 <span class="n">_initial</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The find_all function targets over multiple levels of the datatree, it returns a list or iterator of the</span>
<span class="sd">        matching  items!</span>

<span class="sd">        The key_path parameter given is normally a list. This can be a list of keys or TagIdx objects. The function</span>
<span class="sd">        will search for the first item in the first level, fo next item in the next level and so on...</span>

<span class="sd">        Absolut and relative key_paths:</span>

<span class="sd">        If the first item is the separator (default: &#39;/&#39;) the find search is like an absolute path and we start at the</span>
<span class="sd">        root of the datatree.</span>
<span class="sd">        If the first item is different, the key_path is relative and we start from the actual</span>
<span class="sd">        item and search the children and sub-children.</span>

<span class="sd">        Single string key_path:</span>
<span class="sd">        If the user searches for string type tags he can use a string with a separator (default: &#39;/&#39;) in between the</span>
<span class="sd">        tags (These type of key_paths will be implicit translated in a list in the function). An index separator</span>
<span class="sd">        (default = &#39;#&#39;) in between the tag and the index can also be used to identify to identify items in the tag</span>
<span class="sd">        family. If the key_path argument is already a list the single keys will not be parsed regarding the</span>
<span class="sd">        str_path_separator anymore.</span>

<span class="sd">        HINT: Quickest find operations can be performed by giving a list containing index integers or TagIdx objects</span>

<span class="sd">        The items can be filtered regarding specific content, for this a look into the available filer constructors:</span>
<span class="sd">        create_xxx_item_filter() might be interesting. The filter method or the filter constant can be given</span>
<span class="sd">        in the item_filter parameter</span>

<span class="sd">        The parameters in detail:</span>

<span class="sd">        :param key_path: single key or list of keys</span>
<span class="sd">                    identification path for the item/items to be searched.</span>
<span class="sd">                    Possible keys:</span>
<span class="sd">                    integer - behaves like normal __getitem__() -&gt; itree_item[key]</span>
<span class="sd">                    TagIdx- behaves like normal __getitem__() -&gt; itree_item[key]</span>
<span class="sd">                    iTreeTagSlice - select a tag sliced group of sub-elements</span>
<span class="sd">                    iTMatch - search pattern can be used too, but keep in mind it must deliver a unique result!</span>
<span class="sd">                    Slice - a slice of indexes (like a special index list)</span>
<span class="sd">                    string - will be parsed by the separators</span>
<span class="sd">                    iterable list/tuple/deque,... -</span>
<span class="sd">                             run over single keys if sub_key is again an iterable it will be taken as an index list</span>
<span class="sd">                             (e.g. [1,2,3] - will go deeper in the tree 1. item; 2. subitem; 3. subsubitem</span>
<span class="sd">                             but [[1,2,3]] - will stay in the first level and deliver 1. item; 2. item; 3. item)</span>

<span class="sd">        :param item_filter: filters the item content regarding NORMAL, TEMPORARY and LINKED flag or a given</span>
<span class="sd">                            filtering method</span>
<span class="sd">        :param default_return: object will be return in case of no match (default = None)</span>
<span class="sd">        :param path_separator: separator character in case of strings for the search levels (default: &quot;/&quot;)</span>
<span class="sd">        :param index_separator: separator character for given tag indexes (default: &quot;#&quot;)</span>
<span class="sd">        :param force_list: False (default) - function delivers sometimes iterators</span>
<span class="sd">                           True - function delivers always lists no iterators (can be much slower)</span>
<span class="sd">        :param _initial: Internal flag that should protect against cyclic constructs</span>
<span class="sd">        :return: list or iterator of matching iTrees; in case of no match and empty list is returned</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">item_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">item_filter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ALL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item_filter</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="c1"># create a filter method</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">item_filter</span>
            <span class="n">item_filter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">key_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># empty key?</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># empty string</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="c1"># is string matching to a tag?</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key_path</span><span class="p">,</span><span class="n">str_index_separator</span><span class="o">=</span><span class="n">str_index_separator</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__build_find_all_result</span><span class="p">(</span><span class="n">items</span><span class="p">,</span>
                                             <span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span><span class="ne">IndexError</span><span class="p">,</span><span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="c1"># we check some other quick exceptions:</span>
            <span class="k">if</span> <span class="n">key_path</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key_path</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;**&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_all</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">)</span>
            <span class="c1"># now we split based on separator</span>
            <span class="n">key_list</span> <span class="o">=</span> <span class="n">key_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">str_path_separator</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="c1"># we must ensure we start from the root</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">key_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">item_filter</span><span class="p">,</span> <span class="n">str_path_separator</span><span class="p">,</span> <span class="n">str_index_separator</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">key_list</span><span class="p">,</span> <span class="n">item_filter</span><span class="p">,</span> <span class="n">str_path_separator</span><span class="p">,</span> <span class="n">str_index_separator</span><span class="p">)</span>
        <span class="c1"># first we check we have a valid tag:</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">_initial</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t</span> <span class="ow">in</span> <span class="p">{</span><span class="nb">int</span><span class="p">,</span><span class="nb">str</span><span class="p">,</span><span class="n">TagIdx</span><span class="p">,</span><span class="n">iTMatch</span><span class="p">,</span><span class="nb">slice</span><span class="p">}):</span>
            <span class="c1"># if not _initial we are in deeper level of the iterator and we interpret here as an index list!</span>
            <span class="n">items</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">key_path</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__build_find_all_result</span><span class="p">(</span><span class="n">items</span><span class="p">,</span>
                                         <span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">)</span>
        <span class="c1"># If we reach this point we expect an iterable object as key_path</span>
        <span class="c1"># that iterates deeper into the tree</span>
        <span class="n">key</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will be overwritten anyway</span>
        <span class="n">new_key_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">sub_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">key_path</span><span class="p">)</span>
        <span class="n">post_item</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">post_post_item</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">set_initial</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">sub_iter</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="c1"># empty iterator!</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">post_item</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">sub_iter</span><span class="p">)</span>
            <span class="n">new_key_path</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="n">post_item</span><span class="p">],</span> <span class="n">sub_iter</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">post_post_item</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">sub_iter</span><span class="p">)</span>
                <span class="c1"># create a new iterator that contains the post items and the original iterator</span>
                <span class="n">new_key_path</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="n">post_item</span><span class="p">,</span> <span class="n">post_post_item</span><span class="p">],</span> <span class="n">sub_iter</span><span class="p">)</span>
                <span class="n">set_initial</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="c1"># there is only one item left in iterator we will give the item directly</span>
                <span class="c1"># as key to the next level find()</span>
                <span class="n">new_key_path</span> <span class="o">=</span> <span class="n">post_item</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">str_path_separator</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_key_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># this is not possible we catch this already but we keep the code to complete the condition</span>
                <span class="k">if</span> <span class="n">item_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">iter</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_initial</span><span class="p">:</span>
                <span class="c1"># cyclic construct we have to break!</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">new_key_path</span><span class="p">,</span>
                                      <span class="n">item_filter</span><span class="p">,</span>
                                      <span class="n">str_path_separator</span><span class="p">,</span>
                                      <span class="n">str_index_separator</span><span class="p">,</span> <span class="n">_initial</span><span class="o">=</span><span class="n">set_initial</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">==</span><span class="s1">&#39;*&#39;</span><span class="p">:</span>
            <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">==</span><span class="s1">&#39;**&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_all</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item_filter</span><span class="p">,</span>
                               <span class="n">str_path_separator</span><span class="p">,</span>
                               <span class="n">str_index_separator</span><span class="p">,</span> <span class="n">_initial</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># result can only be a single item</span>
        <span class="k">if</span> <span class="n">new_key_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="c1"># we will not go deeper</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># iter into the next level</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">new_key_path</span><span class="p">,</span>
                                 <span class="n">item_filter</span><span class="p">,</span>
                                 <span class="n">str_path_separator</span><span class="p">,</span>
                                 <span class="n">str_index_separator</span><span class="p">,</span>
                                 <span class="n">_initial</span><span class="o">=</span><span class="n">set_initial</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.find"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_path</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">,</span> <span class="n">default_return</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">str_path_separator</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">,</span>
             <span class="n">str_index_separator</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The find function targets over multiple levels of the datatree, it returns single items only! This means in</span>
<span class="sd">        case the key_path targets to multiple items the default_return will be given. If the key_path targets to a</span>
<span class="sd">        family with only one item inside  or the item_filter extracts only one item in a family</span>
<span class="sd">        the item will be given back as result. For multiple result utilize the find_all() method (which is slower).</span>
<span class="sd">        HINT: The method will deliver a default_return when ever in the whole key_path a match is not unique.</span>
<span class="sd">              This means iteration is stopped here and even that a deeper iteration with the defined filtering might</span>
<span class="sd">              deliver at least a unique result. To ensure to find this deeper results you must utilize the slower</span>
<span class="sd">              find_all() method.</span>

<span class="sd">        The key_path parameter given is normally a list. This can be a list of keys or TagIdx objects. The function</span>
<span class="sd">        will search for the first item in the first level, fo next item in the next level and so on...</span>

<span class="sd">        Absolut and relative key_paths:</span>

<span class="sd">        If the first item is the separator (default: &#39;/&#39;) the find search is like an absolute path and we start at the</span>
<span class="sd">        root of the datatree. For compatibility reasons with find_all we accept  a leading &quot;./&quot;</span>
<span class="sd">        (or to be exact: &quot;.%s&quot;#str_path_separator) as absolute path indicator.</span>
<span class="sd">        If the first item is different, the key_path is relative and we start from the actual</span>
<span class="sd">        item and search the children and sub-children.</span>

<span class="sd">        Single string key_path:</span>
<span class="sd">        If the user searches for string type tags he can use a string with a separator (default: &#39;/&#39;) in between the</span>
<span class="sd">        tags (Those key_paths will be implicit translated in a list). An index separator (default = &#39;#&#39;) in between</span>
<span class="sd">        the tag and the index can also be used in this case. If the argument is already a list the single keys will not</span>
<span class="sd">        be parsed regarding the str_path_separator.</span>

<span class="sd">        HINT: If datatree contains tags with characters that used for separators or the all match &#39;*&#39; character</span>
<span class="sd">              the find() result might contain that tagged item instead of the expected separated or wildcard match.</span>

<span class="sd">        HINT: Quickest find operations can be performed by giving a list containing index integers or TagIdx objects</span>

<span class="sd">        The parameters in detail:</span>

<span class="sd">        :param key_path: single key or list of keys</span>
<span class="sd">                    identification path for the item/items to be searched.</span>
<span class="sd">                    Possible keys:</span>
<span class="sd">                    integer - behaves like normal __getitem__() -&gt; itree_item[key]</span>
<span class="sd">                    TagIdx- behaves like normal __getitem__() -&gt; itree_item[key]</span>
<span class="sd">                    iTreeTagSlice - select a tag sliced group of sub-elements</span>
<span class="sd">                    iTMatch - search pattern can be used too, but keep in mind it must deliver a unique result!</span>
<span class="sd">                    Slice - a slice of indexes (like a special index list)</span>
<span class="sd">                    string - will be parsed by the separators, special string &#39;*&quot; is as interpreted as any match</span>
<span class="sd">                    iterable list/tuple/deque,... -</span>
<span class="sd">                             run over single items</span>
<span class="sd">        :param item_filter: filters the item content regarding NORMAL, TEMPORARY and LINKED flag or a given</span>
<span class="sd">                            filtering method</span>
<span class="sd">        :param default_return: object will be return in case of no match (default = None)</span>
<span class="sd">        :param path_separator: separator character in case of strings for the search levels (default: &quot;/&quot;)</span>
<span class="sd">        :param index_separator: separator character for given tag indexes (default: &quot;#&quot;)</span>
<span class="sd">        :param _initial: Internal flag that should protect against cyclic constructs</span>
<span class="sd">        :return: iTree single item</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># internally we use the find_all() to get a list of items</span>
        <span class="c1"># and than return single match or default_return depending on result items</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">key_path</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">,</span>
                               <span class="n">str_path_separator</span><span class="o">=</span><span class="n">str_path_separator</span><span class="p">,</span>
                               <span class="n">str_index_separator</span><span class="o">=</span><span class="n">str_index_separator</span><span class="p">)</span>
        <span class="c1"># here we check if the iterator contains a unique item:</span>
        <span class="n">item_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">item_iter</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="c1"># empty iterator!</span>
            <span class="k">return</span> <span class="n">default_return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">post_item</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">item_iter</span><span class="p">)</span>
            <span class="c1"># no StopIteration Exception! more then one element we return no match</span>
            <span class="k">return</span> <span class="n">default_return</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="c1"># match!</span>
            <span class="k">return</span> <span class="n">item</span></div>

<div class="viewcode-block" id="iTree.index"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The index method allows to search for the index of the item in a parent object</span>
<span class="sd">        This is especially useful if you must use a item_filter. The delivered index is delivered relative</span>
<span class="sd">        to the given item filter!</span>

<span class="sd">        For the item index of the item in the unfiltered tree (ALL) it&#39;s recommended</span>
<span class="sd">        to use the idx property instead: (parent.index(item,ALL) == item.idx)</span>

<span class="sd">        :param item: item index should be delivered for</span>
<span class="sd">        :param item_filter: filter integer; method can not handle filter methods yet!</span>
<span class="sd">        :return: index integer of the item relative to the given filter</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="nb">int</span><span class="p">,</span> <span class="n">TagIdx</span><span class="p">}:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">item</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="s1">&#39;Given item is not children of this iTree!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">item_filter</span> <span class="o">==</span> <span class="n">ALL</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">item_filter</span> <span class="o">==</span> <span class="n">LINKED</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">LINKED</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="s1">&#39;Given item is not found in this iTree!&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sibling</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">i</span></div>

    <span class="c1"># predefined filter queries</span>

<div class="viewcode-block" id="iTree.create_data_key_filter"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.create_data_key_filter">[docs]</a>    <span class="k">def</span> <span class="nf">create_data_key_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="n">data_key</span><span class="o">=</span><span class="s1">&#39;__NOKEY__&#39;</span><span class="p">,</span><span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        create a item_filter method regarding a specific data key</span>
<span class="sd">        :param data_key: key that should be filtered out - if no key is given the no key item will be filtered</span>
<span class="sd">        :param item_filter: pre filtering method or integer with filter constant</span>
<span class="sd">        :return: specific item filter method that delivers True/False when item is given</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item_filter</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">item_filter</span>
            <span class="n">item_filter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">(</span><span class="n">item_filter</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">data_key</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">data</span><span class="p">))</span></div>

<div class="viewcode-block" id="iTree.create_data_key_match_filter"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.create_data_key_match_filter">[docs]</a>    <span class="k">def</span> <span class="nf">create_data_key_match_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="n">match_pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">,):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        create a item_filter method searching for a specific data content</span>
<span class="sd">        :param match_pattern: checks if a data key matches to the given pattern</span>
<span class="sd">                             (fnmatch() is internally used for the checks)</span>
<span class="sd">                             (non str, byte values will be taken as not matching)</span>
<span class="sd">        :param item_filter: pre filtering method or integer with filter constant</span>
<span class="sd">        :return: specific item filter method</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item_filter</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">item_filter</span>
            <span class="n">item_filter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">(</span><span class="n">item_filter</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="kc">True</span> <span class="ow">in</span>
                                    <span class="p">{((</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="nb">str</span><span class="p">,</span><span class="nb">bytes</span><span class="p">})</span>
                                           <span class="ow">and</span> <span class="p">(</span><span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">match_pattern</span><span class="p">))</span> <span class="ow">or</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()}))</span></div>

<div class="viewcode-block" id="iTree.create_data_value_filter"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.create_data_value_filter">[docs]</a>    <span class="k">def</span> <span class="nf">create_data_value_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        create a item_filter method searching for a specific data content</span>
<span class="sd">        :param data_value: data content the method will search for</span>
<span class="sd">        :param item_filter: pre filtering method or integer with filter constant</span>
<span class="sd">        :return: specific item filter method</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item_filter</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">item_filter</span>
            <span class="n">item_filter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">(</span><span class="n">item_filter</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="kc">True</span> <span class="ow">in</span> <span class="p">{</span><span class="n">v</span> <span class="o">==</span> <span class="n">data_value</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()}))</span></div>

<div class="viewcode-block" id="iTree.create_data_value_match_filter"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.create_data_value_match_filter">[docs]</a>    <span class="k">def</span> <span class="nf">create_data_value_match_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match_pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        create a item_filter method searching for a specific data content</span>
<span class="sd">        :param match_pattern: checks if a data value matches to the given pattern</span>
<span class="sd">                             (fnmatch() is internally used for the checks)</span>
<span class="sd">                             (non str, byte values will be taken as not matching)</span>
<span class="sd">        :param item_filter: pre filtering method or integer with filter constant</span>
<span class="sd">        :return: specific item filter method</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item_filter</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">item_filter</span>
            <span class="n">item_filter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">(</span><span class="n">item_filter</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="kc">True</span> <span class="ow">in</span>
                                    <span class="p">{((</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="nb">str</span><span class="p">,</span><span class="nb">bytes</span><span class="p">})</span>
                                           <span class="ow">and</span> <span class="p">(</span><span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">match_pattern</span><span class="p">))</span> <span class="ow">or</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()}))</span></div>


<div class="viewcode-block" id="iTree.create_item_match_filter"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.create_item_match_filter">[docs]</a>    <span class="k">def</span> <span class="nf">create_item_match_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        create a item_filter method searching for a specific data content</span>
<span class="sd">        :param match: iTMatch object or any match object with a check function for iTree objects</span>
<span class="sd">        :param item_filter: pre filtering method or integer with filter constant</span>
<span class="sd">        :return: specific item filter method</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item_filter</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">item_filter</span>
            <span class="n">item_filter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">((</span><span class="n">item</span><span class="o">.</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="p">(</span><span class="n">item_filter</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="ow">and</span> <span class="n">match</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">item</span><span class="p">))</span></div>

    <span class="c1"># serialize + file operations</span>

<div class="viewcode-block" id="iTree.load_links"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.load_links">[docs]</a>    <span class="k">def</span> <span class="nf">load_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        load all linked items</span>
<span class="sd">        :param force: False (default) - load only if not already loaded</span>
<span class="sd">                      True - load even if already loaded (update)</span>
<span class="sd">        :return: True - success</span>
<span class="sd">                 False - load failed</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">load_ok</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_link</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">force</span> <span class="ow">or</span>  <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_link_loaded</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="o">.</span><span class="n">file_path</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s1">&#39;Source file of the link not found!&#39;</span><span class="p">)</span>
                <span class="n">full_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="o">.</span><span class="n">file_path</span><span class="p">,</span> <span class="n">load_links</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="o">.</span><span class="n">key_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">load_item</span> <span class="o">=</span> <span class="n">full_tree</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">load_item</span> <span class="o">=</span> <span class="n">full_tree</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="o">.</span><span class="n">key_path</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">load_item</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">iTree</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s1">&#39;Given key_path is not matching or unique!&#39;</span><span class="p">)</span>
                <span class="c1"># now we take over the tree</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="c1"># here we run a special extend (we don&#39;t care about parents and is_linked flag)</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">iTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">load_item</span><span class="p">:</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span>
                    <span class="n">cache</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">_cache</span>
                    <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>
                    <span class="n">sl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                    <span class="n">tag</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">tag</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">family</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
                        <span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span> <span class="o">=</span> <span class="n">family</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">BLIST_SWITCH</span><span class="p">:</span>
                            <span class="n">m</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">family</span> <span class="o">=</span> <span class="n">blist</span><span class="p">(</span><span class="n">family</span><span class="p">)</span>
                        <span class="n">family</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">m</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">_tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">_flags</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">_flags</span> <span class="o">|</span> <span class="n">LINKED</span>
                    <span class="n">item</span><span class="o">.</span><span class="n">load_links</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_map</span> <span class="o">=</span> <span class="n">load_item</span><span class="o">.</span><span class="n">_map</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_link</span><span class="o">.</span><span class="n">set_loaded</span><span class="p">(</span><span class="n">load_item</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span><span class="n">load_item</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="o">|</span><span class="n">LINKED</span>
                <span class="n">load_ok</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">linked_flag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">is_linked</span><span class="p">:</span>
                <span class="n">linked_flag</span><span class="o">=</span><span class="n">LINKED</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">():</span>
                <span class="n">load_ok</span> <span class="o">=</span> <span class="n">load_ok</span> <span class="ow">or</span> <span class="n">i</span><span class="o">.</span><span class="n">load_links</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>
                <span class="n">i</span><span class="o">.</span><span class="n">_flags</span><span class="o">=</span><span class="n">i</span><span class="o">.</span><span class="n">_flags</span><span class="o">|</span><span class="n">linked_flag</span>
        <span class="k">return</span> <span class="n">load_ok</span></div>

<div class="viewcode-block" id="iTree.loads"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.loads">[docs]</a>    <span class="k">def</span> <span class="nf">loads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_str</span><span class="p">,</span> <span class="n">check_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">load_links</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        create an iTree object by loading from a string</span>

<span class="sd">        If not overloaded or reinitialized the iTree Standard Serializer will be used. In this case we expect a</span>
<span class="sd">        matching JSON representation.</span>

<span class="sd">        :param data_str: source string that contains the iTree information</span>
<span class="sd">        :param check_hash: True the hash of the file will be checked and the loading will be stopped if it doesn&#39;t match</span>
<span class="sd">                           False - do not check the iTree hash</span>
<span class="sd">        :param load_links: True - linked iTree objects will be loaded</span>
<span class="sd">        :return: iTree object loaded from file</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_serializer</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data_str</span><span class="p">,</span> <span class="n">check_hash</span><span class="o">=</span><span class="n">check_hash</span><span class="p">,</span> <span class="n">load_links</span><span class="o">=</span><span class="n">load_links</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.load"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">check_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">load_links</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        create an iTree object by loading from a file</span>

<span class="sd">        If not overloaded or reinitialized the iTree Standard Serializer will be used. In this case we expect a</span>
<span class="sd">        matching JSON representation.</span>

<span class="sd">        :param file_path: file path to the file that contains the iTree information</span>
<span class="sd">        :param check_hash: True the hash of the file will be checked and the loading will be stopped if it doesn&#39;t match</span>
<span class="sd">                           False - do not check the iTree hash</span>
<span class="sd">        :param load_links: True - linked iTree objects will be loaded</span>
<span class="sd">        :return: iTree object loaded from file</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_serializer</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">check_hash</span><span class="o">=</span><span class="n">check_hash</span><span class="p">,</span> <span class="n">load_links</span><span class="o">=</span><span class="n">load_links</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.dumps"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.dumps">[docs]</a>    <span class="k">def</span> <span class="nf">dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_serializer</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.dump"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_path</span><span class="p">,</span> <span class="n">pack</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_serializer</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_path</span><span class="p">,</span> <span class="n">pack</span><span class="o">=</span><span class="n">pack</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.renders"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.renders">[docs]</a>    <span class="k">def</span> <span class="nf">renders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_serializer</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">renders</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="iTree.render"><a class="viewcode-back" href="../../itertree.html#itertree.iTree.render">[docs]</a>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_serializer</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_serializer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="c1"># helpers</span>
    <span class="k">def</span> <span class="nf">__iter_to_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">match_key</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">tag_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">match_key</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">yield</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">__get_family_insertion_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">item_idx</span><span class="p">,</span> <span class="n">last_index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">family</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">family</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">item_idx</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">last_index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">last_index</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">family</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">idx</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">item_idx</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_family_insertion_idx</span><span class="p">(</span><span class="n">family</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">item_idx</span><span class="p">,</span> <span class="n">last_index</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_family_insertion_idx</span><span class="p">(</span><span class="n">family</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">item_idx</span><span class="p">,</span> <span class="n">last_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__unsupport_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported operand or function in iTree&#39;</span><span class="p">)</span>

    <span class="c1"># find helper methods for differenet types of keys</span>

    <span class="k">def</span> <span class="nf">__build_find_all_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        helper function for find method</span>
<span class="sd">        :param result: result found by the key</span>
<span class="sd">        :param default_result: flag</span>
<span class="sd">        :param item_filter: filter</span>
<span class="sd">        :return: final result</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">is</span> <span class="n">iTree</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">result</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">item_filter</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">result</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item_filter</span><span class="p">(</span><span class="n">item</span><span class="p">),</span> <span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__find_single_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_path</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        find normal item via __getitem__ in the children</span>
<span class="sd">        :param key_path: key</span>
<span class="sd">        :param item_filter: filter method</span>
<span class="sd">        :return: list with one item</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__build_find_all_result</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">item_filter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__find_tag_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag_slice</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">tag_slice</span><span class="o">.</span><span class="n">idx</span>  <span class="c1"># slice!?</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__find_single_item</span><span class="p">(</span><span class="n">key_path</span><span class="o">=</span><span class="n">tag_slice</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">)</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag_slice</span><span class="o">.</span><span class="n">tag</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">family</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__build_find_all_result</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">),</span> <span class="n">idx</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">idx</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span>
                                <span class="n">idx</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__find_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slice_obj</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">),</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span>
                                <span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__find_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_obj</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">idx</span> <span class="ow">in</span> <span class="n">set_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__find_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">item_filter</span><span class="o">=</span><span class="n">ALL</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">match</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">item</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_children</span><span class="p">(</span><span class="n">item_filter</span><span class="o">=</span><span class="n">item_filter</span><span class="p">))</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2021

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>